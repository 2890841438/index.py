{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Although I've never used PHP, I like its hot-swap mechanism. I expect to use index.py to make Python's Web program deployment easier. Index.py can automatically update your Python file changes to the server. Managing your index.py service, maybe you only need one ftp. Install Index.py requires python version at least 3.6. pip install -U index.py Or get the latest version on Github pip install -U git+https://github.com/abersheeran/index.py How to use Make a folder that name is views and create index.py in it. Write the following in index.py from index.view import View class HTTP ( View ): def get ( self ): return \"hello world\" develop Execute the command index-cli dev in the same directory as views . deploy In linux, you can use index-cli gunicorn start to start server. -w INT : The number of worker processes for handling requests. This value is best when it is equal to the number of cores of the CPU. -d : Increasing this parameter will cause the program to run in the background and redirect the log to the log.index in the current directory. In windows......maybe you can use index-cli dev to deploy, it uses asyncio to build the server, performance is not too bad.","title":"Getting started"},{"location":"#install","text":"Index.py requires python version at least 3.6. pip install -U index.py Or get the latest version on Github pip install -U git+https://github.com/abersheeran/index.py","title":"Install"},{"location":"#how-to-use","text":"Make a folder that name is views and create index.py in it. Write the following in index.py from index.view import View class HTTP ( View ): def get ( self ): return \"hello world\"","title":"How to use"},{"location":"#develop","text":"Execute the command index-cli dev in the same directory as views .","title":"develop"},{"location":"#deploy","text":"In linux, you can use index-cli gunicorn start to start server. -w INT : The number of worker processes for handling requests. This value is best when it is equal to the number of cores of the CPU. -d : Increasing this parameter will cause the program to run in the background and redirect the log to the log.index in the current directory. In windows......maybe you can use index-cli dev to deploy, it uses asyncio to build the server, performance is not too bad.","title":"deploy"},{"location":"config/","text":"Configuration The configuration allows the configuration to be automatically separated by ENV, and lowercase letters in all keys are automatically converted to uppercase. You can use Config() anywhere in the program to use the configuration, which is a class that uses the singleton pattern. Like this from index import Config print ( Config ()) Environment variables At startup, index automatically reads INDEX_DEBUG and INDEX_ENV from the environment variable. Environment variables take precedence over configuration files. This means that you can use environment variables to force the value of ENV to be specified. like this INDEX_DEBUG = on INDEX_ENV = pro Config file At the root of your web program, the configuration in config.json will be read when index starts. example: { \"log_level\" : \"info\" , \"allow_underline\" : true , \"allowed_hosts\" : [ \"localhost\" ], \"cors_settings\" : { \"allow_origins\" : [ \"*\" ], \"allow_methods\" : [ \"GET\" ], \"allow_credentials\" : false }, \"dev\" : { \"host\" : \"0.0.0.0\" , \"debug\" : true }, \"pro\" : { \"host\" : \"127.0.0.1\" , \"port\" : \"41900\" , \"log_level\" : \"warning\" } } All available configurations ENV Default: \"dev\" env is an important configuration that allows for the distinction between different configuration environments. DEBUG Default: False I don't think this needs explanation. In the environment variable, INDEX_DEBUG is true when it is on or True, otherwise it is false. LOG_LEVEL Default: \"info\" log_level has five values, the corresponding table to the logging is as follows log_level logging \"critical\" logging.CRITICAL \"error\" logging.ERROR \"warning\" logging.WARNING \"info\" logging.INFO \"debug\" logging.DEBUG HOST Default: \"127.0.0.1\" host specifies the bound HOST address. PORT Default: 4190 port pecifies the bound HOST port. ALLOWED_HOSTS Default: [\"*\"] allowed_hosts allows you to restrict access to this application's host. Some examples: - [\"*\"] - [\"example.com\", \"*example.com\"] - [\"example.com\", \"test.com\"] ALLOW_UNDERLINE Default: False allow_underline allows you to determine if an underscore is allowed in the URI by configuring a boolean value. When it is false, if _ exists in the uri, it will be replaced with - and redirected. CORS_SETTINGS Default: { \"allow_origins\": (), \"allow_methods\": (\"GET\",), \"allow_headers\": (), \"allow_credentials\": False, \"allow_origin_regex\": None, \"expose_headers\": (), \"max_age\": 600, } The following arguments are supported: allow_origins A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods A list of HTTP methods that should be allowed for cross-origin requests. You can use ['*'] to allow all standard methods. allow_headers A list of HTTP request headers that should be supported for cross-origin requests. You can use ['*'] to allow all headers. The Accept, Accept-Language, Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials Indicate that cookies should be supported for cross-origin requests. expose_headers Indicate any response headers that should be made accessible to the browser. max_age Sets a maximum time in seconds for browsers to cache CORS responses. Explain environmental isolation Some configurations of the development and production environments may differ when developing a website. Index.py has this isolation built in. You only need to specify the value of INDEX-_ENV in the environment variable. It will first read from the specified environment. If the specified environment does not exist, it will continue to look up. Like this configuration file { \"log_level\" : \"info\" , \"allow_underline\" : true , \"allowed_hosts\" : [ \"localhost\" ], \"cors_settings\" : { \"allow_origins\" : [ \"*\" ], \"allow_methods\" : [ \"GET\" ], \"allow_credentials\" : false }, \"dev\" : { \"host\" : \"0.0.0.0\" , \"debug\" : true }, \"pro\" : { \"host\" : \"127.0.0.1\" , \"port\" : \"41900\" , \"log_level\" : \"warning\" } } Config().DEBUG will be True when you specify the value of INDEX_ENV as \"dev\". When you specify the value of INDEX_ENV as \"pro\", when using Config().DEBUG , it will first look for \"pro\". When it is not found, it continues to look up. However, this configuration file does not have DEBUG configured on root, so the default value of False is used. Other configurations are also like this.","title":"Configuration"},{"location":"config/#configuration","text":"The configuration allows the configuration to be automatically separated by ENV, and lowercase letters in all keys are automatically converted to uppercase. You can use Config() anywhere in the program to use the configuration, which is a class that uses the singleton pattern. Like this from index import Config print ( Config ())","title":"Configuration"},{"location":"config/#environment-variables","text":"At startup, index automatically reads INDEX_DEBUG and INDEX_ENV from the environment variable. Environment variables take precedence over configuration files. This means that you can use environment variables to force the value of ENV to be specified. like this INDEX_DEBUG = on INDEX_ENV = pro","title":"Environment variables"},{"location":"config/#config-file","text":"At the root of your web program, the configuration in config.json will be read when index starts. example: { \"log_level\" : \"info\" , \"allow_underline\" : true , \"allowed_hosts\" : [ \"localhost\" ], \"cors_settings\" : { \"allow_origins\" : [ \"*\" ], \"allow_methods\" : [ \"GET\" ], \"allow_credentials\" : false }, \"dev\" : { \"host\" : \"0.0.0.0\" , \"debug\" : true }, \"pro\" : { \"host\" : \"127.0.0.1\" , \"port\" : \"41900\" , \"log_level\" : \"warning\" } }","title":"Config file"},{"location":"config/#all-available-configurations","text":"ENV Default: \"dev\" env is an important configuration that allows for the distinction between different configuration environments. DEBUG Default: False I don't think this needs explanation. In the environment variable, INDEX_DEBUG is true when it is on or True, otherwise it is false. LOG_LEVEL Default: \"info\" log_level has five values, the corresponding table to the logging is as follows log_level logging \"critical\" logging.CRITICAL \"error\" logging.ERROR \"warning\" logging.WARNING \"info\" logging.INFO \"debug\" logging.DEBUG HOST Default: \"127.0.0.1\" host specifies the bound HOST address. PORT Default: 4190 port pecifies the bound HOST port. ALLOWED_HOSTS Default: [\"*\"] allowed_hosts allows you to restrict access to this application's host. Some examples: - [\"*\"] - [\"example.com\", \"*example.com\"] - [\"example.com\", \"test.com\"] ALLOW_UNDERLINE Default: False allow_underline allows you to determine if an underscore is allowed in the URI by configuring a boolean value. When it is false, if _ exists in the uri, it will be replaced with - and redirected. CORS_SETTINGS Default: { \"allow_origins\": (), \"allow_methods\": (\"GET\",), \"allow_headers\": (), \"allow_credentials\": False, \"allow_origin_regex\": None, \"expose_headers\": (), \"max_age\": 600, } The following arguments are supported: allow_origins A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods A list of HTTP methods that should be allowed for cross-origin requests. You can use ['*'] to allow all standard methods. allow_headers A list of HTTP request headers that should be supported for cross-origin requests. You can use ['*'] to allow all headers. The Accept, Accept-Language, Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials Indicate that cookies should be supported for cross-origin requests. expose_headers Indicate any response headers that should be made accessible to the browser. max_age Sets a maximum time in seconds for browsers to cache CORS responses.","title":"All available configurations"},{"location":"config/#explain-environmental-isolation","text":"Some configurations of the development and production environments may differ when developing a website. Index.py has this isolation built in. You only need to specify the value of INDEX-_ENV in the environment variable. It will first read from the specified environment. If the specified environment does not exist, it will continue to look up. Like this configuration file { \"log_level\" : \"info\" , \"allow_underline\" : true , \"allowed_hosts\" : [ \"localhost\" ], \"cors_settings\" : { \"allow_origins\" : [ \"*\" ], \"allow_methods\" : [ \"GET\" ], \"allow_credentials\" : false }, \"dev\" : { \"host\" : \"0.0.0.0\" , \"debug\" : true }, \"pro\" : { \"host\" : \"127.0.0.1\" , \"port\" : \"41900\" , \"log_level\" : \"warning\" } } Config().DEBUG will be True when you specify the value of INDEX_ENV as \"dev\". When you specify the value of INDEX_ENV as \"pro\", when using Config().DEBUG , it will first look for \"pro\". When it is not found, it continues to look up. However, this configuration file does not have DEBUG configured on root, so the default value of False is used. Other configurations are also like this.","title":"Explain environmental isolation"},{"location":"response/","text":"The program must respond to a index.responses.Response object or its subclass object. The list of available Response classes is as follows: Response HTMLResponse PlainTextResponse JSONResponse RedirectResponse StreamingResponse FileResponse TemplateResponse But in the Middleware & View example, it's okay to return dict directly. Because the str and dict types of handlers are already built into the Index. Custom response handle Index.py allows custom response types. The following is the definition of the dict : from index.responses import register_type , JSONResponse @register_type ( dict ) def json_type ( * args ): if len ( args ) > 3 : raise ValueError ( \"The response cannot exceed three parameters.\" ) # judge status code and headers try : if not isinstance ( args [ 1 ], int ): raise TypeError ( \"The response status code must be integer.\" ) if not isinstance ( args [ 2 ], dict ): raise TypeError ( \"The response headers must be dictionary.\" ) except IndexError : pass return JSONResponse ( * args ) This will enable index.py to handle the return of the str type, and at the same time handle the returned headers and status code . It should be noted that such a function must return a index.responses.Response object or its subclass object.","title":"Response"},{"location":"response/#custom-response-handle","text":"Index.py allows custom response types. The following is the definition of the dict : from index.responses import register_type , JSONResponse @register_type ( dict ) def json_type ( * args ): if len ( args ) > 3 : raise ValueError ( \"The response cannot exceed three parameters.\" ) # judge status code and headers try : if not isinstance ( args [ 1 ], int ): raise TypeError ( \"The response status code must be integer.\" ) if not isinstance ( args [ 2 ], dict ): raise TypeError ( \"The response headers must be dictionary.\" ) except IndexError : pass return JSONResponse ( * args ) This will enable index.py to handle the return of the str type, and at the same time handle the returned headers and status code . It should be noted that such a function must return a index.responses.Response object or its subclass object.","title":"Custom response handle"},{"location":"view/","text":"View In all Python files that you expect to handle HTTP requests, you need to define a class called HTTP . Example: from index.view import View class HTTP ( View ): def get ( self ): return templates . TemplateResponse ( \"home.html\" , { \"request\" : self . request }) def post ( self ): return { \"message\" : \"some error in server\" }, 500 , { \"server\" : \"index.py\" } In the class, you can define the following methods to handle the corresponding HTTP request. get post put patch delete head options trace The self.request is the starlette.requests.Request object. Middleware Define a class named Middleware in any __init__.py under views, which will intercept or process any request or response that passes this path. Middleware inherits from MiddlewareMixin and there are two methods to override it. process_request(request) This method must return None , otherwise the process will be terminated early. process_response(request, response) This method must return a response. example Write the following in views/__init__.py from index.middleware import MiddlewareMixin from index.config import logger class Middleware ( MiddlewareMixin ): async def process_request ( self , request ): logger . info ( \"enter first process request\" ) async def process_response ( self , request , response ): logger . info ( \"enter last process response\" ) return response Visit /index.py in browser, to see the following information in the console INFO: enter first process request INFO: enter last process response INFO: ('127.0.0.1', 21203) - \"GET /index.py HTTP/1.1\" 200 And then, write the following in views/about/__init__.py from index.middleware import MiddlewareMixin from index.config import logger class Middleware ( MiddlewareMixin ): def process_request ( self , request ): logger . info ( \"enter second process request\" ) def process_response ( self , request , response ): logger . info ( \"enter second last process response\" ) return response Visit /about/me.py in browser, to see the following information in the console INFO: enter first process request INFO: enter second process request INFO: enter second last process response INFO: enter last process response INFO: ('127.0.0.1', 21223) - \"GET /about/me.py HTTP/1.1\" 200","title":"Middleware & View"},{"location":"view/#view","text":"In all Python files that you expect to handle HTTP requests, you need to define a class called HTTP . Example: from index.view import View class HTTP ( View ): def get ( self ): return templates . TemplateResponse ( \"home.html\" , { \"request\" : self . request }) def post ( self ): return { \"message\" : \"some error in server\" }, 500 , { \"server\" : \"index.py\" } In the class, you can define the following methods to handle the corresponding HTTP request. get post put patch delete head options trace The self.request is the starlette.requests.Request object.","title":"View"},{"location":"view/#middleware","text":"Define a class named Middleware in any __init__.py under views, which will intercept or process any request or response that passes this path. Middleware inherits from MiddlewareMixin and there are two methods to override it. process_request(request) This method must return None , otherwise the process will be terminated early. process_response(request, response) This method must return a response.","title":"Middleware"},{"location":"view/#example","text":"Write the following in views/__init__.py from index.middleware import MiddlewareMixin from index.config import logger class Middleware ( MiddlewareMixin ): async def process_request ( self , request ): logger . info ( \"enter first process request\" ) async def process_response ( self , request , response ): logger . info ( \"enter last process response\" ) return response Visit /index.py in browser, to see the following information in the console INFO: enter first process request INFO: enter last process response INFO: ('127.0.0.1', 21203) - \"GET /index.py HTTP/1.1\" 200 And then, write the following in views/about/__init__.py from index.middleware import MiddlewareMixin from index.config import logger class Middleware ( MiddlewareMixin ): def process_request ( self , request ): logger . info ( \"enter second process request\" ) def process_response ( self , request , response ): logger . info ( \"enter second last process response\" ) return response Visit /about/me.py in browser, to see the following information in the console INFO: enter first process request INFO: enter second process request INFO: enter second last process response INFO: enter last process response INFO: ('127.0.0.1', 21223) - \"GET /about/me.py HTTP/1.1\" 200","title":"example"}]}